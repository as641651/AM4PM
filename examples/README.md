## Runner:

Runners are objects that executes an external command (such as calling a python or julia or bash script). Running the external command outputs a csv file in a format that can be handled by the data_integration sub module. The inputs are the names of the script files that executes the required operation.

The execution of the scripts can either be local, in the backend or submitted to a batch system.

## Input:

Implementation that generates and measures variant codes for an input linear algebra expression. The generated code has timestamps inserted before and after the kernel calls.

# Local Measurements:
### 1. Generate variants for an instance of a linear algebra expression.
An instance refers to an linear algebra expression with a specific operand sizes

```python
operand_sizes = ["75","75","6","75","75"]
script_dir = "sample_generation/"
runner_local = RunnerVariants(operand_sizes, script_dir)
```


Here, generate-variants-linnea.py is a script file that generates variant codes using the Linnea interface

```python
runner_local.generate_variants_for_measurements(generation_script="generate-variants-linnea.py")
```
output: here the image of the first output must be added.

### 2. Measure variants
Executing generate-variants-linnea.py creates a subdirectory experiments/75_75_6_75_75/, which consists of the generated code and a number of scripts.

```python
!ls sample_generation/experiments/75_75_6_75_75/
```


output: an image of the output

runner.jl is a script that executes all the variants once and outputs a file run_times.csv that consists of the run time for each variant.

```python
runner_local.measure_variants(app="julia", runner_script="runner.jl")
```
output:

```python
!ls sample_generation/experiments/75_75_6_75_75/
```
output:

generate_measurement_scripts.py is a file that generates a measurement script with a specific identifier (run_id) that repeats a given set of variant for a said (rep) numnber of times. For instance, the resulting script for identifier 0 is runner_competing_0.jl

```python
measurements_script = "generate-measurements-script.py"
variants = ['algorithm0', 'algorithm1']
reps = 3
run_id = 0
```
```python
runner_local.generate_measurements_script(measurements_script, variants, run_id, reps)
```
output:

```python
!ls sample_generation/experiments/75_75_6_75_75/
```
output:

Executing runner_competing_0.jl measures the variants and outputs a csv file run_times_competing_0.csv consisting of the execution time measurements
``python
runner_competing_script = "runner_competing_0.jl"
runner_local.measure_variants(app="julia", runner_script=runner_competing_script)
```
output:

```python
!ls sample_generation/experiments/75_75_6_75_75/
```
output:

### Data integration
This module converts the csv files generated by the runner to pandas data frames.

The input is the directory consisting of the csv files

```python
dc_local = DataCollector("sample_generation/experiments/75_75_6_75_75/")
```
For instance, lets read case_table.csv

```python
dc_local.get_table("case_table.csv")
```
output:


DataCollector offers methods to read the files without having to input the file names, provided the file names adhere to the PA4Algs standards.

```python
case_table = dc_local.get_case_table()
case_table
```

output:

```python
measurements_table = dc_local.get_runtimes_table()
measurements_table
```
output11:


### Data processing
The data_proccessing module takes as input the data frames of the case table and the measurement tables (according to the PA4Algs standards) and performs a number of data processing operations.

#### FilterOnKPIs
The FilterOnKPI class filters the variants with the highest FLOP count or execution times within a cretain threshold from the minimum oberved execution time
```python
filterAlgs = FilterOnKPIs(case_table, measurements_table)
```
```python
filterAlgs.filter_on_flops_and_rel_duration(1.2)
```
output:

```python
filterAlgs.filter_on_best_flops()
```
output:

```python
filterAlgs.get_alg_seq_sorted_on_duration()
```
output:

#### CaseDurationManager
In practise, measuremnets from multiple tables have to be aggregated. For instance, in order to measure the relative performance of algorithms in PA4Algs (Algorithm Ranking), the variants are measured iteratively, and the execution times from different csv files have to be combined into a single data frame. To this end, CaseDurationManager class is used
